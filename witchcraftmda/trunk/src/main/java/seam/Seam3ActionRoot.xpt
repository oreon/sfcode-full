«IMPORT wcprofile»

«EXTENSION org::openarchitectureware::uml2::profile::profiling»
«EXTENSION template::GeneratorExtensions»
«EXTENSION template::associationExtensions»

«EXTENSION template::WebExtensions»


«DEFINE Root FOR uml::Model»
	«EXPAND PackageRoot FOREACH allOwnedElements().typeSelect(uml::Package)»
	«REM»«EXPAND SeamEntityQueryRoot::Root FOR this» «ENDREM»
	«EXPAND richfaces::PagesRoot::genPages»
«ENDDEFINE»

«DEFINE PackageRoot FOR uml::Package»
	«EXPAND BaseGen FOREACH allOwnedElements().typeSelect(wcprofile::Entity)»
	«EXPAND BaseGen FOREACH allOwnedElements().typeSelect(wcprofile::MappedSuperClass)»
	«EXPAND ManualGen FOREACH allOwnedElements().typeSelect(wcprofile::Entity)»
«ENDDEFINE»
	


«DEFINE ManualGen FOR wcprofile::Entity»

	«FILE getWebPackagePath("Action")  man_path »
	
package « getWebPackageName() »;

import javax.ejb.Stateful;
import javax.enterprise.context.ConversationScoped;
import javax.inject.Named;	

@Named
@Stateful
@ConversationScoped
public class «name»Action extends «name»ActionBase implements java.io.Serializable{
	
}
	«ENDFILE»

«ENDDEFINE»

«DEFINE BaseGen FOR wcprofile::MappedSuperClass»
	«EXPAND AbstractGen FOR this»
«ENDDEFINE»

«DEFINE BaseGen FOR wcprofile::Entity»
	«IF !isAbstract»
		«EXPAND BaseGenImpl FOR this»
	«ELSE»
		«EXPAND AbstractGen FOR this»
	«ENDIF»
«ENDDEFINE»


«DEFINE AbstractGen FOR uml::Class»
	«FILE getWebPackagePath("Action")  man_path »
		
		package « getWebPackageName() »;
		
		«EXPAND genImports FOR this»	
		import org.witchcraft.seam.action.BaseAction; 
		import org.witchcraft.base.entity.BaseEntity;
		
		public  abstract class «name»Action<T extends BaseEntity> extends BaseAction<T> implements java.io.Serializable{
			
		}
	«ENDFILE»
«ENDDEFINE»


«DEFINE BaseGenImpl FOR wcprofile::Entity»
«FILE getWebPackagePath("ActionBase")   »
package « getWebPackageName() »;

import « packageName() ».«name»;

import org.witchcraft.seam.action.BaseAction; 

«EXPAND genImports FOR this»
«FOREACH getMultiValued() AS a-»
import «a.type.fqn()»;
«ENDFOREACH»


public abstract class «name»ActionBase extends «getFirstParent() == null || getFirstParent().length == 0  || !parentIsMappedSuperClass() ? "BaseAction<" +  name + ">" :
	 parents().get(0).getActionFqn() + getGenericType(parents().get(0)) » implements java.io.Serializable{

	protected Predicate[] getSearchPredicates(Root<«name»> root) {

		CriteriaBuilder builder = entityManager.getCriteriaBuilder();
		List<Predicate> predicatesList = new ArrayList<Predicate>();

		/*
		String name = search.getName();
		if (name != null && !"".equals(name)) {
			predicatesList.add(builder.like(root.<String> get("name"),
					'%' + name + '%'));
		}
		
		int stock = search.getStock();
		if (stock != 0) {
			predicatesList.add(builder.equal(root.get("stock"), stock));
		}*/

		return predicatesList.toArray(new Predicate[predicatesList.size()]);
	}

	@Override
	protected Class<«name»> getEntityClass() {
		return «name».class;
	}
	
	public «name» createInstance(){
		return new «name»();
	}
	
	public «name» get«name»() {
		return this.entity;
	}
	
	public void set«name»(«name» «asVar()») {
		this.entity = «asVar()»;
	}
	
	/** This function is responsible for loading associations for the given entity e.g. when viewing an order, we load the customer so
	 * that customer can be shown on the customer tab within viewOrder.xhtml
	 * @see org.witchcraft.seam.action.BaseAction#loadAssociations()
	 */
	public void loadAssociations(){
	
		«REM»comment
		«FOREACH getOutgoingAssociations() AS e»
		«IF !e.type.isAbstract»
		if («asVar()».get«e.name.toFirstUpper()»() != null) {
			«e.name»Action.setInstance(getEntity().get«e.name.toFirstUpper()»());
		}
		«ENDIF»
		«ENDFOREACH»
		«ENDREM»
		
		«FOREACH getMultiValued() AS e»
			initList«e.name.toFirstUpper()»(); 
		«ENDFOREACH»
		
		«FOREACH getLeadingManyToMany() AS e»
			initList«e.name.toFirstUpper()»(); 
			initListAvailable«e.name.toFirstUpper()»(); 
		«ENDFOREACH»
	}
	
	public void updateAssociations(){
		«FOREACH getNonComposedManyAssociations() AS a»
		«a.type.fqn()» «a.name» =(«a.type.fqn()») org.jboss.seam.Component.getEntity("«a.type.name.toFirstLower()»");
		«a.name».set«a.opposite.name.toFirstUpper()»(«asVar()»);
		events.raiseTransactionSuccessEvent("archived«a.type.name»");
		«ENDFOREACH»
	}
	
	
	«EXPAND genCompositeCode FOREACH getMultiValued() -»
	«EXPAND genManyToMany FOREACH getLeadingManyToMany() -»
	
	
	public void updateComposedAssociations(){
		«EXPAND updateList FOREACH getMultiValued() -»
		«EXPAND updateList FOREACH getLeadingManyToMany() -»
	}
	
	
	public void clearLists(){
		«FOREACH getMultiValued() AS a -»
			list«a.name.toFirstUpper()».clear();
		«ENDFOREACH»
		
		«FOREACH getLeadingManyToMany() AS a -»
			list«a.name.toFirstUpper()».clear();
		«ENDFOREACH»
	}
	

	«EXPAND template::Root::genOperation FOREACH getAllOperations()»
	
	
}
«ENDFILE»
«ENDDEFINE»

«DEFINE genCurrentUser FOR wcprofile::Column»
	instance.set«name.toFirstUpper()»(«name»Action.getCurrentLoggedIn«type.name»());
«ENDDEFINE»

«DEFINE updateList FOR uml::Property»
	  if (list«name.toFirstUpper()» != null) {
		getEntity().get«name.toFirstUpper()»().clear();
		getEntity().get«name.toFirstUpper()»().addAll(list«name.toFirstUpper()»);
	  }
«ENDDEFINE»


«DEFINE genManyToMany FOR uml::Property»
	«EXPAND genList( "") FOR this»
	«EXPAND genList( "Available") FOR this»
«ENDDEFINE»



«DEFINE genCompositeCode FOR uml::Property»
	
	«EXPAND genList("") FOR this»
	«LET "list" + name.toFirstUpper()  AS currentList»
	public void delete«name.toFirstUpper()»(int index){
		«currentList».remove(index);
	}
	
	éé@Begin(join=true)
	public void add«name.toFirstUpper()»(){
		init«currentList.toFirstUpper()»();
		«type.name» «name» = new «type.name»();
		«IF opposite != null && opposite.isNavigable()»
			«name».set«opposite.name.toFirstUpper()»(getEntity());
		«ENDIF»
		get«currentList.toFirstUpper()»().add(«name»);
	}
	
	«ENDLET»	
«ENDDEFINE»

«DEFINE genList(String prefix) FOR uml::Property»
	
	«LET "list" + prefix + name.toFirstUpper()  AS currentList»
	
	protected List<«type.fqn()»> «currentList» = new ArrayList<«type.fqn()»>();
	
	void init«currentList.toFirstUpper()»(){
	
		«IF isLeadingManyToMany() && prefix == "Available"»
			«currentList» = getEntityManager().createQuery("select r from «type.name» r").getResultList();
			«currentList».removeAll(getEntity().get«name.toFirstUpper()»());
		«ELSE»
		if(«currentList».isEmpty())
			«currentList».addAll(getEntity().get«name.toFirstUpper()»());
		«ENDIF»	
	}
	
	«IF prefix == "Available"»@Begin(join=true)«ENDIF»
	public List<«type.fqn()»> get«currentList.toFirstUpper()»() {
		«REM»«IF isLeadingManyToMany() && prefix == "Available"» init«currentList.toFirstUpper()»(); «ENDIF»comment«ENDREM»
		prePopulate«currentList.toFirstUpper()»();
		return «currentList»;
	}
	
	public void prePopulate«currentList.toFirstUpper()»() {}

	public void set«currentList.toFirstUpper()»(List<«type.fqn()»> «currentList») {
		this.«currentList» = «currentList»;
	}
	«ENDLET»
«ENDDEFINE»


«DEFINE genImports FOR uml::Class»
import java.util.ArrayList;
import java.util.List;

import javax.faces.event.ValueChangeEvent;
import javax.faces.model.SelectItem;
import javax.persistence.EntityManager;

import org.apache.commons.lang.StringUtils;

import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;


import org.witchcraft.base.entity.FileAttachment;

import org.apache.commons.io.FileUtils;
«ENDDEFINE»

