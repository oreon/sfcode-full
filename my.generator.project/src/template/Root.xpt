«IMPORT wcprofile»

«EXTENSION org::openarchitectureware::uml2::profile::profiling»
«EXTENSION template::GeneratorExtensions»
«EXTENSION template::associationExtensions»

«DEFINE Root FOR uml::Model»
	«EXPAND PackageRoot FOREACH allOwnedElements().typeSelect(uml::Package)»
	«EXPAND ORMGen::Root FOR this»
«ENDDEFINE»

«DEFINE PackageRoot FOR uml::Package»
	«EXPAND ClassRoot FOREACH allOwnedElements().typeSelect(uml::Class)»
	«EXPAND ClassRoot FOREACH allOwnedElements().typeSelect(uml::Interface)»
	«EXPAND EnumGen FOREACH allOwnedElements().typeSelect(uml::Enumeration)»
«ENDDEFINE»

«DEFINE ClassRoot FOR uml::Class»
	«IF name != null && package != null && getAppliedStereotypes().size == 0»
	«FILE packagePath() +"/" +name + ".java" man_path »
		package « packageName() »;
		«EXPAND genImports FOR this»
		«EXPAND genClassBody FOR this»
	«ENDFILE»
	«ENDIF»
«ENDDEFINE»



«DEFINE ClassRoot FOR wcprofile::AbstractEntity»
	«IF name != null && package != null»
	
	«FILE packagePath() +"/" +name+".java"»
		package « packageName() »;
		«EXPAND genImports FOR this»
		«EXPAND genPersistenceImports FOR this»
		«EXPAND genClassBody FOR this»
	«ENDFILE»
	
	«ENDIF»
«ENDDEFINE»

«DEFINE ClassRoot FOR wcprofile::WebAction»

«ENDDEFINE»



«DEFINE ClassRoot FOR uml::Interface»
	«FILE packagePath() +"/" +name+".java"»
	package « packageName() »;
	«EXPAND genImports »
	
	
	public interface «name» «parents().size > 0 ?" extends " + parents().get(0).name:""»{
		 «EXPAND genOperationDecl FOREACH getAllOperations()»
	}
	«ENDFILE»
«ENDDEFINE»




«DEFINE genClassBody FOR uml::Class »
	public class «name» «getParent()» «getInterfaces()»{
		«EXPAND genDecl FOREACH getAllAttributes() »
		«EXPAND genGetterSetter FOREACH getAllAttributes() »
		«EXPAND genOperation FOREACH getAllOperations()»
	}
«ENDDEFINE»

«DEFINE genClassBody FOR wcprofile::Entity»
	@Entity
	@Table(name="«getTableName()»")
	@Filter(name = "archiveFilterDef") 
	«IF !isAbstract»@Name("«asVar()»")
	@Indexed
	«IF cacheType != null »@Cache(usage = CacheConcurrencyStrategy.«cacheType.name»)«ENDIF»
	@AnalyzerDef(name = "customanalyzer",
		  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
		  filters = {
		    @TokenFilterDef(factory = LowerCaseFilterFactory.class),
		    @TokenFilterDef(factory = SnowballPorterFilterFactory.class, params = {
		      @Parameter(name = "language", value = "English")
		    })
	})
	«ELSE»
	@Inheritance(strategy=InheritanceType.«inheritanceType.name»)
	«ENDIF»
	public  «IF isAbstract» abstract «ENDIF» class «name» «getParent()»  «getInterfaces()» «getImplementedInterfaces().isEmpty  ?" implements " : ","»  «getAuditable()?"Auditable, ":""» java.io.Serializable {
		private static final long serialVersionUID = «serialver()»;
		
		«EXPAND genDecl FOREACH getAllAttributes() »
		«EXPAND genGetterSetter FOREACH getAllAttributes() »
		
		«EXPAND genPopupAndDisplayname FOR this»
	    
	    //Empty setter , needed for richfaces autocomplete to work 
	    public void setDisplayName(String name){
	    }
	    
	    «EXPAND genSearchFieldsArray FOR this»
	    
	    
	    «IF isProcessToken()»
	    	private Long processId;

			private String processName;
		
			public Long getProcessId() {
				return processId;
			}
		
			public void setProcessId(Long processId) {
				this.processId = processId;
			}

			public String getProcessName() {
				return processName;
			}
		
			public void setProcessName(String processName) {
				this.processName = processName;
			}
	    «ENDIF»
	    «REM»comment
	    «EXPAND genOperation FOREACH getAllOperations()»
	    «ENDREM»
	}
«ENDDEFINE»


«DEFINE genPopupAndDisplayname FOR uml::Class»
	«IF !getAllAttributes().isEmpty»
		@Transient
	    public String getDisplayName(){
	    	try {
				return «getDisplayName()»;
			} catch (Exception e) {
				return "Exception - " + e.getMessage();
			}
	    }
	    «ENDIF»
	    
	    «IF !getAllAttributes().isEmpty && popupInfo != null»
		@Transient
	    public String getPopupInfo(){
	    	try {
				return «popupInfo»;
			} catch (Exception e) {
				return "Exception - " + e.getMessage();
			}
	    }
	    «ENDIF»
«ENDDEFINE»


«DEFINE genSearchFieldsArray FOR uml::Class»

	/** This method is used by hibernate full text search - override to add additional fields
	 * @see org.witchcraft.model.support.BusinessEntity#retrieveSearchableFieldsArray()
	 */
	@Override
	public List<String> listSearchableFields() {
		List<String> listSearchableFields = new ArrayList<String>();
		listSearchableFields.addAll(super.listSearchableFields());
		«FOREACH getAllAttributes() AS e»
			«IF e.isString()» listSearchableFields.add("«e.name»"); «ENDIF»
		«ENDFOREACH»
		
		«REM»For full text we need to add composed assoications as well - e.g. searching an order by product «ENDREM»
		«EXPAND genEmbeddedAndAssociatedSearch FOREACH getComposed()»
		«EXPAND genEmbeddedAndAssociatedSearch FOREACH getEmbeddable()»
		return listSearchableFields;
	}
«ENDDEFINE»

«DEFINE genEmbeddedAndAssociatedSearch FOR uml::Property»
«FOREACH type.getAllAttributes() AS attr»
	«IF attr.isString()» listSearchableFields.add("«name».«attr.name»");«ENDIF»
«ENDFOREACH»
«ENDDEFINE»

«DEFINE genClassBody FOR wcprofile::Embeddable»
	@Embeddable
	@Indexed
	public class «name» «getParent()» «getInterfaces()» implements  java.io.Serializable{
		private static final long serialVersionUID = «serialver()»;
		
		«EXPAND genDecl FOREACH getAllAttributes() »
		«EXPAND genGetterSetter FOREACH getAllAttributes() »
	}
«ENDDEFINE»





«DEFINE genClassBody FOR wcprofile::MappedSuperClass»
	@MappedSuperclass
	public class «name» «getParent()» «getInterfaces()»{
		private static final long serialVersionUID = «serialver()»;
		
		«EXPAND genDecl FOREACH getAllAttributes() »
		«EXPAND genGetterSetter FOREACH getAllAttributes() »
		
		«EXPAND genPopupAndDisplayname FOR this»
	    
	    «EXPAND genSearchFieldsArray FOR this»
	}
«ENDDEFINE»

«DEFINE genOperation FOR uml::Operation»
	«visibility» «getOpReturnType()» «getOpReturnTypeTemplateParam()»  «name» («getParametersSignature()»){ 
		«IF type != null»
			return null;
		«ENDIF»
	}
«ENDDEFINE»

«DEFINE genOperationDecl FOR uml::Operation»
	«visibility» «getOpReturnType()» «name» («getParametersSignature()»);
«ENDDEFINE»


«DEFINE genOperation FOR wcprofile::NamedQueryOp»
	«visibility» «getOpReturnType()» «name» («getParametersSignature()»){ 
		«IF getParameters().length > 0 »
			return execute«getQyeryTypeByReturnType()»NamedQuery("«name»", «getParameters()»);
		«ELSE»
			return execute«getQyeryTypeByReturnType()»NamedQuery("«name»");
		«ENDIF»
		
	}
«ENDDEFINE»


«DEFINE genUnqNamedQryOp FOR wcprofile::Column»
	«IF uniqueProperty »
	public «class.fqn()» findByUnq«name.toFirstUpper()» («getParametersSignature()»){ 
		return executeSingleResultNamedQuery("findByUnq«name.toFirstUpper()»", «name»);
	}
	«ENDIF»
«ENDDEFINE»


«DEFINE genUnqNamedQryOp FOR uml::Property»
«ENDDEFINE»


«DEFINE gen FOR uml::Generalization»
«ENDDEFINE»

«DEFINE genDecl FOR wcprofile::DerivedProperty»
	
«ENDDEFINE»

«DEFINE genDecl FOR wcprofile::DerivedFormula»
	
«ENDDEFINE»


«DEFINE genDecl FOR uml::Property»
	«IF isMultivalued()»
		«IF opposite!= null && opposite.isMultivalued() » «REM»Many to many relationship«ENDREM»
			«IF  isAggregate()»
			@ManyToMany(cascade={CascadeType.PERSIST, CascadeType.MERGE})
		    @JoinTable(
		        name="«opposite.name»_«name»",
		        joinColumns=@JoinColumn(name="«opposite.name»_ID"),
		        inverseJoinColumns=@JoinColumn(name="«name»_ID")
		    )
		    «ELSE»
		    	 @ManyToMany(mappedBy="«opposite.name»")
			«ENDIF»
		«ELSE»
		@OneToMany(«IF isBidirectional()»mappedBy = "«getOppositeName() »", «ENDIF» fetch = FetchType.LAZY, cascade = CascadeType.ALL)
		«REM»comment«IF isComposite()»@Cascade(value=org.hibernate.annotations.CascadeType.DELETE_ORPHAN)«ENDIF»«ENDREM»
		@JoinColumn(name = "«getOppositeName()»_ID", nullable = «getAssocOptional()»)
		@OrderBy("dateCreated DESC")
		«IF type.name != class.name»@IndexedEmbedded«ENDIF»
		«ENDIF»
		private Set<«type.fqnForPackage(this.class)»> «name» = new HashSet<«type.fqnForPackage(this.class)»>();
	«ELSE»
		«IF association != null &&  !type.isEmbeddable()»
			«REM»comment//«isOneOnOne()» unq «isUnique» opp is unq«opposite.isUnique» mult «isMultivalued()» opp mult «opposite.isMultivalued()» «opposite.isMultivalued() == null ? "unspec" : "spec-blank" » «ENDREM»
			@« isOneOnOne()?"One":"Many"»ToOne(«IF isOneOnOne() && isAggregate()»mappedBy = "« class.asVar()»", «ENDIF»optional=«getAssocOptional()», fetch=FetchType.LAZY, cascade = CascadeType.ALL)
			«IF !(isOneOnOne() && isAggregate())»@JoinColumn(name="«name»_id", nullable=«getAssocOptional()», updatable = «getAssocUpdatable()») «ENDIF»
    		«IF type.name != class.name»@ContainedIn«ENDIF»
		«ENDIF» 
		«IF type.isEmbeddable() || isContainedAssoc() || (isColumn()  && autocomplete)»
			«IF type.name != class.name && type.isEmbeddable() »@IndexedEmbedded «EXPAND EmbeddedAttributes FOR this»  «ENDIF»
			protected «type.fqnForPackage(this.class)» «name» = new «type.fqnForPackage(this.class)»();
		«ELSE»
			«EXPAND genPropertyDecl FOR this»
		«ENDIF»
	«ENDIF»
«ENDDEFINE»

«DEFINE EmbeddedAttributes FOR uml::Property»
	@AttributeOverrides( {
	«FOREACH type.getAllAttributes() AS e ITERATOR iter»
		@AttributeOverride(name="«e.name»", column = @Column(name="«name»_«e.name»") ) «IF iter.counter1 < type.getAllAttributes().size » , «ENDIF»
	«ENDFOREACH»
    } )
«ENDDEFINE»

«DEFINE genPropertyDecl FOR uml::Property»
	«type.name.getTypeAnnotation()»
	«EXPAND genBaseDecl FOR this»
«ENDDEFINE»

«DEFINE genPropertyDecl FOR wcprofile::Column»
	«getValidatorAnnotations()»
	«getLengthAnnotations()»
	«getUniqueAnnotations()»
	«getTransient()»
	«type.name.getTypeAnnotation()»
	«getColJpaAnnotations()»
	«EXPAND genBaseDecl FOR this»
«ENDDEFINE»

«DEFINE genBaseDecl FOR uml::Property»
	
	«IF type.name == "imageFile"»  
	@Embedded
    @AttributeOverrides( {
        @AttributeOverride(name="name", column = @Column(name="«name»_name") ),
        @AttributeOverride(name="contentType", column = @Column(name="«name»_contentType") ),
        @AttributeOverride(name="data", column = @Column(name="«name»_data", length = 4194304) )
    } )
	protected FileAttachment «name» = new FileAttachment();	
	«ELSE»
		«IF isColumn() && (derivedFormula != null || derivedProperty != null)»@Transient«ENDIF»
		«IF isString()» @Field(index = Index.TOKENIZED) @Analyzer(definition = "customanalyzer") «ENDIF»
		protected «type.fqnForPackage(this.class)» «name» «getDefault() != null?" = " +getDefaultVal(type):""» 
			«isColumn() && defaultExpression != null?" = " + defaultExpression:""» ;
	«ENDIF»
	
«ENDDEFINE»




«DEFINE genGetterSetter FOR uml::Property»
	«IF isMultivalued()»
		public void set«name.toFirstUpper()»(Set<«type.fqnForPackage(this.class)»> «name»){
			this.«name» = «name»;
		}
		
		public Set<«type.fqnForPackage(this.class)»> get«name.toFirstUpper()»( ){
			return «name»;
		}
	«ELSE»
		public void set«name.toFirstUpper()»(«type.fqnForPackage(this.class)» «name»){
			this.«name» = «name»;
		}
		
		public «type.fqnForPackage(this.class)» get«name.toFirstUpper()»( ){
			«IF isColumn() && derivedProperty != null »
			try {
				return «derivedProperty»;
			} catch (Exception e) {
				return "";
			}
			«ELSE»
				return «name»;
			«ENDIF»
		}
	«ENDIF»
«ENDDEFINE»

«DEFINE genGetterSetter FOR wcprofile::DerivedProperty»
//derived property - «name»
public «type.fqnForPackage(this.class)» get«name.toFirstUpper()»( ){
	return «derivation != null ? derivation :  name»;
	return «name»;
}
«ENDDEFINE»


«DEFINE EnumGen FOR uml::Enumeration»
	«FILE packagePath() + "/"+ name +".java"»  
	package «packageName()»;
	
	public enum «name» {	
		
		«FOREACH  ownedLiteral AS e»
			«e.name»,
		«ENDFOREACH»
		;
		
		«name»() { }
		
		public String getName(){
        	return this.toString();
    	}
    	
    	public String getDisplayName(){
        	return this.toString();
    	}
	} 
	«ENDFILE»
«ENDDEFINE»



«DEFINE genImports FOR uml::Type»
	import java.util.ArrayList;
	import java.util.HashSet;
	import java.util.List;
	import java.util.Set;
	import java.util.Date;
«ENDDEFINE»


«DEFINE genPersistenceImports FOR uml::Class»
	import javax.persistence.*;
	import org.hibernate.validator.*;
	
	import org.apache.solr.analysis.LowerCaseFilterFactory;
	import org.apache.solr.analysis.SnowballPorterFilterFactory;
	import org.apache.solr.analysis.StandardTokenizerFactory;
	import org.hibernate.annotations.Cache;
	import org.hibernate.annotations.Formula;
	import org.hibernate.annotations.CacheConcurrencyStrategy;
	import org.hibernate.annotations.Filter;
	import org.hibernate.annotations.Cascade;
	
	import org.hibernate.search.annotations.AnalyzerDef;
	import org.hibernate.search.annotations.Analyzer;
	import org.hibernate.search.annotations.Field;
	import org.hibernate.search.annotations.Index;
	import org.hibernate.search.annotations.Indexed;
	import org.hibernate.search.annotations.Parameter;
	import org.hibernate.search.annotations.TokenFilterDef;
	import org.hibernate.search.annotations.TokenizerDef;
	import org.hibernate.search.annotations.ContainedIn;
	import org.hibernate.search.annotations.IndexedEmbedded;
	
	
	import org.hibernate.validator.Length;
	import org.hibernate.validator.NotNull;
	import org.jboss.seam.annotations.Name;
	import org.witchcraft.base.entity.BusinessEntity;
	import org.witchcraft.model.support.audit.Auditable;
	import org.witchcraft.base.entity.FileAttachment;
	import org.hibernate.annotations.Filter;
	
	import org.witchcraft.utils.*;
«ENDDEFINE»
