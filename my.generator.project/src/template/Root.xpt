«IMPORT wcprofile»

«EXTENSION org::openarchitectureware::uml2::profile::profiling»
«EXTENSION template::GeneratorExtensions»

«DEFINE Root FOR uml::Model»
	«EXPAND PackageRoot FOREACH allOwnedElements().typeSelect(uml::Package)»
«ENDDEFINE»

«DEFINE PackageRoot FOR uml::Package»
	«EXPAND ClassRoot FOREACH allOwnedElements().typeSelect(uml::Class)»
	«EXPAND ClassRoot FOREACH allOwnedElements().typeSelect(uml::Interface)»
	«EXPAND EnumGen FOREACH allOwnedElements().typeSelect(uml::Enumeration)»
«ENDDEFINE»


«DEFINE ClassRoot FOR uml::Interface»
	«FILE packagePath() +"/" +name+".java"»
	package « packageName() »;
	
	public interface «name» «parents().size > 0 ?" extends " + parents().get(0).name:""»{
	
	}
	«ENDFILE»
«ENDDEFINE»


«DEFINE genClassBody FOR uml::Class»
	public class «name» «getParent()» «getInterfaces()»{
		«EXPAND genDecl FOREACH getAllAttributes() »
		«EXPAND genGetterSetter FOREACH getAllAttributes() »
	}
«ENDDEFINE»

«DEFINE genClassBody FOR wcprofile::Entity»
	@Entity
	@Table(name="«tableName!=null?tableName.toLowerCase():name.toLowerCase()»")
	@Name("«asVar()»")
	@Filter(name = "archiveFilterDef") 
	public class «name» «getParent()» «getInterfaces()»{
		«EXPAND genDecl FOREACH getAllAttributes() »
		«EXPAND genGetterSetter FOREACH getAllAttributes() »
		 
		«IF !getAllAttributes().isEmpty»
		@Transient
	    public String getDisplayName(){
	    	return «getDisplayName()»;
	    }
	    «ENDIF»
	    
	}
«ENDDEFINE»

«DEFINE genClassBody FOR wcprofile::Embeddable»
	@Embeddable
	public class «name» «getParent()» «getInterfaces()»{
		«EXPAND genDecl FOREACH getAllAttributes() »
		«EXPAND genGetterSetter FOREACH getAllAttributes() »
	}
«ENDDEFINE»

«DEFINE genClassBody FOR wcprofile::MappedSuperClass»
	@MappedSuperclass
	public class «name» «getParent()» «getInterfaces()»{
		«EXPAND genDecl FOREACH getAllAttributes() »
		«EXPAND genGetterSetter FOREACH getAllAttributes() »
		
		«IF !getAllAttributes().isEmpty»
		@Transient
	    public String getDisplayName(){
	    	return «getDisplayName()»;
	    }
	    «ENDIF»
	}
«ENDDEFINE»


«DEFINE ClassRoot FOR uml::Class»
	«FILE packagePath() +"/" +name+".java"»
		package « packageName() »;
		«EXPAND genImports FOR this»
		«EXPAND genClassBody FOR this»
	«ENDFILE»
«ENDDEFINE»

«REM»
«DEFINE ClassRoot FOR wcprofile::Entity»
	«FILE packagePath() +"/"  +name+".java"»
	package «packageName()»;
	
	«EXPAND genImports FOR this»
	
	 «tableName != null ?("(table=" + tableName + ")"):""») 
	«EXPAND genClassBody FOR this»
	«ENDFILE»
«ENDDEFINE»
«ENDREM»

«DEFINE genImports FOR uml::Class»
	import java.util.Set;
	import java.util.HashSet;
	import java.util.Date;
	
	import javax.persistence.*;
	import org.hibernate.validator.*;
	
	import org.jboss.seam.annotations.Name;
	import org.witchcraft.base.entity.*;
	import org.hibernate.annotations.Filter;
«ENDDEFINE»

«DEFINE gen FOR uml::Operation»
	«name»;
«ENDDEFINE»

«DEFINE gen FOR uml::Generalization»
«ENDDEFINE»

«DEFINE gen FOR wcprofile::NamedQuery»
	@nq(value=«name»)
	«visibility» «type.name» «name» (){ }
«ENDDEFINE»


«DEFINE genDecl FOR uml::Property»
	«IF isMultivalued()»
		//«name»->«opposite.name» ->«opposite.type.name»->«association.endType.get(0).name»->«opposite.association.endType.get(0).name»
		«IF opposite!= null && opposite.isMultivalued() » «REM»Many to many relationship«ENDREM»
			«IF this.isColumn() && this.leadingInManyToMany»
			@ManyToMany(cascade={CascadeType.PERSIST, CascadeType.MERGE})
		    @JoinTable(
		        name="«opposite.name»_«name»",
		        joinColumns=@JoinColumn(name="«opposite.name»_ID", unique=true),
		        inverseJoinColumns=@JoinColumn(name="«name»_ID", unique=true)
		    )
		    «ELSE»
		    	 @ManyToMany(mappedBy="«opposite.name»")
			«ENDIF»
		«ELSE»
		@OneToMany(mappedBy = "«opposite.name»", fetch = FetchType.LAZY, cascade = CascadeType.ALL)
		@JoinColumn(name = "«class.name»_ID", nullable = «getAssocOptional()»)
		«ENDIF»
		private Set<«type.fqnForPackage(this.class)»> «name» = new HashSet<«type.fqnForPackage(this.class)»>();
	«ELSE»
		«IF association != null &&  !type.isEmbeddable()»
			@ManyToOne(optional=«getAssocOptional()», fetch=FetchType.LAZY)
    		@JoinColumn(name="«name»_id", nullable=«getAssocOptional()», unique=true)
		«ENDIF»
		«IF type.isEmbeddable()»
			protected «type.fqnForPackage(this.class)» «name» = new «type.name»();
		«ELSE»
			«EXPAND genPropertyDecl FOR this»
		«ENDIF»
	«ENDIF»
«ENDDEFINE»

«DEFINE genPropertyDecl FOR uml::Property»
	«type.name.getTypeAnnotation()»
	«EXPAND genBaseDecl FOR this»
«ENDDEFINE»

«DEFINE genPropertyDecl FOR wcprofile::Column»
	«getValidatorAnnotations()»
	«getLengthAnnotations()»
	«getUniqueAnnotations()»
	«getTransient()»
	«type.name.getTypeAnnotation()»
	«EXPAND genBaseDecl FOR this»
«ENDDEFINE»

«DEFINE genBaseDecl FOR uml::Property»
	protected «type.fqnForPackage(this.class)» «name» «getDefault() != null?" = " +getDefaultVal(type):""»;
«ENDDEFINE»




«DEFINE genGetterSetter FOR uml::Property»
	«IF isMultivalued()»
		public void set«name.toFirstUpper()»(Set<«type.fqnForPackage(this.class)»> «name»){
			this.«name» = «name»;
		}
		
		public Set<«type.fqnForPackage(this.class)»> get«name.toFirstUpper()»( ){
			return «name»;
		}
	«ELSE»
		public void set«name.toFirstUpper()»(«type.fqnForPackage(this.class)» «name»){
			this.«name» = «name»;
		}
		
		public «type.fqnForPackage(this.class)» get«name.toFirstUpper()»( ){
			return «isColumn() && derivedProperty != null ? derivedProperty :  name»;
		}
	«ENDIF»
«ENDDEFINE»



«DEFINE EnumGen FOR uml::Enumeration»
	«FILE packagePath() + "/"+ name +".java"»  
	package «packageName()»;
	
	public enum «name» {		
		«FOREACH  ownedLiteral AS e»
			«e.name»,
		«ENDFOREACH»
	} 
	«ENDFILE»
«ENDDEFINE»

